= Can Python Overload Methods?

The title of the post is a question that seems to come up quite often.
Not surprisingly, it usually comes from people who have worked
in languages where method/function overloading is a big part of the
language design.

According to Wikipedia,
____
...function overloading or method overloading is the ability to create
multiple methods of the same name with different implementations.
Calls to an overloaded function will run a specific implementation
of that function appropriate to the context of the call, allowing one
function call to perform different tasks depending on context.
____

== Typing

The above defintion certainly applies in the context of a strongly
typed language. As a simplistic example, you might have a class which
should work whether the value argument to the constructor is an integer
or a double-precision floating point number. Consider this C++ syntax
pseudo-code:

[source,c++]
----
class Foo {
    public:
        Foo(int x);
        Foo(double x);
        ...
};

Foo::Foo(int x)
{
    ...
}

Foo::Foo(double x)
{
    ...
}

Foo a = new(Foo(12));
Foo b = new(Foo(18.0));
----

So, two different constructor functions both named after the class
(as that is the C\++ syntax). C++ needs that information up front, or
the compiler will throw type errors on compilation, as it's an error to
pass an argument of one type to a function expecting a different type.

Python syntax does not allow multiple functions to take the same name.
In fact, the result can be a little surprising at first, since function
definitions are just executable statements, where the meaning is "create
a function object and assign a reference to it to the name".  So two
function defs of the same name is just like assigning two different
values to a variable, the second one replaces the first:

[source,python]
----
>>> def a():
...     print "Hello"
...
>>> def a(x):
...     print "Hi, argument was", x
...
>>> a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: a() takes exactly 1 argument (0 given)
>>> a("hello")
Hi, argument was hello
----

However, since Python is not a strongly typed language, this situation is
not necessarily an issue. There's no problem with the following snippet:

[source,python]
----
class Foo:
    def __init__(self, x):
        self.x = x

a = Foo(12)
b = Foo(18.0)
----

Of course, you have to make sure the method you write in Python can
actually handle arguments of different types.  Python will let you check
that, along these lines:

[source,python]
----
>>> x = 12
>>> isinstance(x, int)
True
>>> x = 18.0
>>> isinstance(x, int)
False
>>> isinstance(x, float)
True
----

But there's a concept often cited in Python circles that it's "Easier
to Ask Forgiveness than Permission" (or EAFP), which suggests that you
just go ahead and try something, and clean up the mess afterwards if it
didn't work.  That's antithetical to some software development theory
which says to check everything first ("look before you leap"), but as long
as you can properly deal with the fallout from problems there's not any
real issue.  That idea isn't unique to Python though it may be expressed
in different ways - exceptions are an example of this way of thinking.

And it turns out Python can often handle differing types without
any problem - it's not an error, for example, to perform arithmetic
operations between an integer and a float. That gets into another concept
often discussed around Python, "duck typing". That is a term which is
intentionally a little silly:

[quote, "Alex Martelli", comp.lang.python]
____
In other words, don't check whether it IS-a duck: check whether it
QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what
subset of duck-like behaviour you need to play your language-games with.
____

In this simple case, if your objective is to perform arithmetic on your
arguments, integers and floats both have methods like add, subtract,
multiply, etc. So there is not a compelling reason to treat them in
different ways.

== Differing Numbers of Arguments

Another case for overloading in static languages is if the method
may need to take different numbers of arguments.  This can come up
in a different ways, for example:

* You want to offer different ways to call, as in a hypotetical
employee database where a new employee can be added by a
("Firstname", "Lastname", Salary) triple, or by a string encoding all
three as "Firstname-Lastname-Salary".
* Evolution: say you've implemented a class, and then later find out
you need to make some extensions to your API which involves passing
an additional parameter.  If you just change the constructor, then all
the code instantiating that class must now change. But by overload
through adding a new constructor plus leaving the old one and adjusting
its behavior so it has a sensible default if the added argument from
the new constructor is not passed old and new code can both be
supported.

Of the two example cases, the second one is fairly easy to handle
in Python. A combination of keyword arguments and/or default arguments
normally does the trick. So we can go from:

[source,python]
----
class Foo:
    def __init__(self, x, y):
        self.x = x

a = Foo(12)
----

to:
[source,python]
----
class Foo:
    def __init__(self, x, y = None):
        self.x = x
        if y:
            self.y = y


a = Foo(12)          # old way still works
b = Foo(12, 18.0)    # new way
----
