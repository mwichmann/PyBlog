= Python Classes: inherit, override, extend

Here is a question that comes up from time to time
with beginners:  ``I defined a derived class but it is
not getting data from the base class.  What\'s going on?''

Here is a bit of example code that shows this problem:

[source,python]
----
include::inherit.py[]
----

But this fails:

[listing]
Traceback (most recent call last):
  File "inherit.py", line 34, in <module>
    print("b.adata:", b.adata)
AttributeError: 'B' object has no attribute 'adata'


Wait, what?  I thought the derived class inherited from
the base class, yet the variable `adata` set in the base
class does not exist?

== Viewing Class Inheritance Details

The short answer is that is how classes work in Python. But
that ends up needing quite a bit of explanation.

Before getting to that, I want to detour to point out how easy
it is to insert print calls to figure out what Python is
doing. Following is an expanded example that adds prints in
a lot of places to help us see what is happening. [Aside:
using print is lazy, use the logging module!]

[source,python]
----
include::override.py[]
----

----
Setting class variables in A	<1>
Setting class variables in B
Begin examination...
Data from classes:
A.clsdataA: class A		<2>
B.clsdataA: class A
Instantiating A as a:
Initializing instance of A	<3>
Data from instance a:
a.clsdataA: class A		<4>
a.dataA: instance of class A
call methA directly from a: A method from class A
Instantiating B as b:
Initializing instance of B	<5>
Data from instance b:
b.clsdataB: class B
b.dataB: instance of class B
b.clsdataA: class A		<6>
call methA from b: A method from class A
Traceback (most recent call last):
  File "./override.py", line 41, in <module>
    print("b.dataA:", b.dataA)
AttributeError: 'B' object has no attribute 'dataA'
----
<1> The two assignments of class data happen
before anything: a class definition is an
executable statement, executed when reached in the file.
<2> You can access the class data before any
instances are created, as per the previous note.
<3> The class A initializer is called when A is instantiated.
<4> Data from an instance of the base class is as expected.
<5> The class B initializer (only) is called when B is instantiated.
<6> The class data from the base class and the method from
the base class are inherited as expected.

So we have a good idea what happened.  Instantiating the
derived class never called the +$$__init__$$+ method in the base class.
That is because inheritance is very straightforward in Python: if
the base class defines something and the derived class does not,
the reference resolves to the one in the base class. But here
we have defined an +$$__init__$$+, so the reference resolves to it.
There is no "magic" in the sense that some methods are 
invoked anyway, even if overridden.
Python has a term for the way things are looked up, 
the 'Method Resolution Order' (MRO).
The MRO documentation is quite detailed because it deals also with complex
multiple inheritance questions (note many OO languages just avoid this
by not allowing multiple inheritance), but the situation here is quite
simple: we just walk up the tree, and if a method is not found in any of
the explicit defintions, it will pick the method from the `object` class,
which is the base of all so-called New-Style Classes. 
This "walk up" concept is very important and we'll come back to it.

So as a first step, we can "fix" our initial problem by
calling in to the base class initializer:

[source,python]
----
class A(object):
    def __init__(self):
        self.dataA = 'instance of class A'

class B(A):
    def __init__(self):
        A.__init__(self)
        self.dataB = 'instance of class B'

b = B()
print(b.dataA)
----

And now the output is as expected:

[listing]
instance of class A

There is a little subtlety here: because we are calling
class `A` by name, rather than through an instance, the
the +$$__init__$$+ method of `A` does not get automatically supplied with
an instance reference and you would get an error (specifically,
`TypeError: __init__() missing 1 required positional argument: 'self'`).
So we need to supply the instance reference explicitly.

This behavior is not limited to the +$$__init__$$+ function,
any method of the base class can be called, which means
the derived class has the flexibility to tailor the behavior
it wants: inherit from the base clase without doing
anything, override the base class, or "extend" the base class by
doing some local work before or after calling the base
class method.
You can even extend methods from builtin classes - the
facility is by no means limited to your own classes.

[sidebar]
.The Method Resolution Order
--
If you are interested in the MRO, it can actually just
be printed out. For the code above, add this line:

[source,python]
----
print(B.__mro__)
----

Which would give this response:

[listing]
(<class '__main__.B'>, <class '__main__.A'>, <type 'object'>)
--

As noted earlier, this was a simple case with no surprises.

[sidebar]
.Introspection
--
Python makes it easy to look inside objects to see what
they look like.  For example, to see data defined in an instance,
we can print out the +$$__dict__$$+ attribute of the instance.
[source,python]
print("Dict:", b.__dict__)

Before adding the the call to the base class initializer:

[listing]
Dict: {'dataB': 'instance of class B'}

After:

[listing]
Dict: {'dataA': 'instance of class A', 'dataB': 'instance of class B'}

So calling the base's +$$__init__$$+ method has added
an entry to the data dictionary of the child instance.
You can see all the defined symbols in the scope of
the instance object by adding this:

[source,python]
print("dir:", dir(b))
--

== The super Method

All of the above is pretty standard stuff about how Python
classes work. There can always be surprises when you come from
a familiar language to a new one and things look kind of
similar but something is subtly different,
but that is just part of learning.

Calling to a base class by name, however, may or may not
be a good idea.  It is very clear what you mean, but it
is not very flexible.  You hardcode a name; if you later
change the definition of the derived class to inherit
from some other class, you have to update any calls to
the previous base class to update the name. And if you
start playing with multiple inheritance 
then you have to do some work to figure out
where to actually call to - see the MRO sidebar. This is
a potential code maintainability issue.

There is a tool to make that happen cleanly, the built
in `super` function. In Python3 `super` is easy to use
in simple cases.  For our modified short example, replace
the explicit call to `A`\'s initializer with this:

[source,python]
----
super().__init__()
----

`super` uses data from the context of the call
to figure out where to delegate it to: the class where the call
appears,  and the ancestry tree of the instance.
So we do not need to supply the `self`
argument in this case, unlike the hardwired call to a class's init method.

`super` in Python2 is a little dfferent, look it up if you
need to use it there.

The "walk up from the bottom" nature of `super` means
you have to give some thought when designing your classes.
From the viewpoint of a given method, calling `super` does
not mean call my immediate parent's method, it means
walk up from `self` until you find it.  Remembering that
`self` written in a method does not mean "me", it means
the instance object I was called with, which could very well
be an instance of a class that derived from me. So be nice
to others who may want to derive from you.

Somewhat surprisingly, `super` is a bit controversial
in the Python community, there have been blog posts and
flame wars on whether it is a good thing or bad thing.
Most of that centers around complex inheritance trees,
especially multiple inheritance.  I see no reason not
to use it as described in this post.  If things get more
complicated, you do need to make sure the arguments line
up between caller and callee, and because `super` doesn't
tell you what the callee is, that is work you have to take
care of manually.

== Summing Up
If you've read this far, it may have occurred that Python classes
are very flexible.  This may be unlike the rather rigid
contstraints of more classical object-oriented languages.
Here is a concept to think about:
____
Classes in Python do not so much inherit as delegate. You
derive from another class in order to reuse its code,
which in practice means your dictionary of methods and data
is pre-populated with references from the class you are "deriving"
from. But you are completely in charge of this relationship.
If you define a name in your class, that goes in the dictionary
in preference to the same name from the base class. If you
do not, think of that as asking the base class to do
that particular bit of work for you since the code is already
implemented. And if you do define a name, you can still ask
the base class to do some of the work for you by calling
into it explicitly, so you are not so much extending a method
as augmenting the one you have provided with code that
already exists elsewhere.
____
